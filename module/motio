/////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	File name: 
//	descripton:
//	version:
//	create:	Date		by
//			2017/4/12	Darren
//		................	......
//	modify:	date		by
//			2017/4/12	Darren
//		...............		......
//	
////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <stdio.h>
#include <pthread.h>

#include "types.h"
#include "xrobot.h" 
#include "serial.h"
#include "config.h"
#include "CThread_motion.h"

#include "wrapper.h"
/*
typedef struct {
   //FUNCALLBACK callback;
   int update;
   float yaw;
   struct timeval post_time;
} V2M_MSG;
*/
extern V2M_MSG vslam_data;

float init_imu_yaw_ang;
float init_vslam_yaw_ang;
float irc_ang = 0;
int run_times;

CThread_motion::CThread_motion()
{
	xro_read_len = 0;
	xro_write_len = 0;
}

CThread_motion::~CThread_motion()
{
}
////////////////////////
void* CThread_motion::process_motion(void *)
{


	while (1)
	{
		//motion control here
		printf("Thread motion here\n");
		motion();
		sleep(1);

		//end of motion control
	}
	return (void *)NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void CThread_motion::create(pthread_t &tid, int sock)
{
	//if(pthread_create(&tid,NULL,process_motion,(void *)sock))
	if (pthread_create(&tid, NULL, process_motion, &sock))
	{
		printf("CThread Created Error \n");
		exit(1);
	}
	else
		printf("**************CThread Created success*******************************************************\n");

}

//////////////////////////
void CThread_motion::exit(int)
{
	pthread_exit(0);
}

/*******************************************************************/
int_32 CThread_motion::line_motion(ppos_ori pinit_pos, ppos_ori pcurrent_pos,
	pxrobot_msg ppre_msg, int_32 trans_vel_d, float des_ang, float cmp_ang)
{

	pos_ori prior_pos;


	int_32 wheel_base = 268;
	int_32 init_time;

	xrobot_msg curr_msg;	//解析后，xrobot的信息
	ctrl_cmd cmd;

	float y, y_d;
	float L_l, L_r;
	float change_angle = 0;
	float slope_line, line_b;
	float theta, theta_d;
	float pre_yaw, curr_yaw;

	pos_ori tem_pos = *pinit_pos;
	//    pinit_pos->x = cos(tem_pos.theta)*tem_pos.x - sin(tem_pos.theta)*tem_pos.y;
	//    pinit_pos->y = sin(tem_pos.theta)*tem_pos.x + cos(tem_pos.theta)*tem_pos.y;
	//    pinit_pos->theta  = tem_pos.theta - tem_pos.theta;
	//    change_angle = tem_pos.theta;

	pinit_pos->x = cos(des_ang)*tem_pos.x - sin(des_ang)*tem_pos.y;
	pinit_pos->y = sin(des_ang)*tem_pos.x + cos(des_ang)*tem_pos.y;
	pinit_pos->theta = pinit_pos->theta - des_ang;
	change_angle = des_ang;

	float init_x = pinit_pos->x;

	//    slope_line = tan(cmp_ang);
	//    line_b = pinit_pos->y - slope_line*pinit_pos->x;
	//    theta_d = cmp_ang;
	slope_line = 0;
	line_b = pinit_pos->y - slope_line*pinit_pos->x;
	theta_d = 0;

	prior_pos = *pinit_pos;
	pre_yaw = imu_msg_struct.yaw;

	while (1)
	{
		if (x_msg_struct.update == 1)
		{
			memcpy(ppre_msg, px_msg_struct, sizeof(curr_msg));
			init_time = x_msg_struct.time;
			x_msg_struct.update = 0;
			break;
		}
	}

	while (1)
	{

		printf("Line motion\n");
		if (x_msg_struct.update == 1)
		{
			memcpy(&curr_msg, px_msg_struct, sizeof(curr_msg));
			px_msg_struct->update = 0;
			run_times++;
		}
		else
		{
			usleep(5000);
			continue;
		}


		L_l = (curr_msg.left_pos - ppre_msg->left_pos)*0.2167;
		L_r = (curr_msg.right_pos - ppre_msg->right_pos)*0.2167;


		curr_yaw = imu_msg_struct.yaw;

		if ((pre_yaw <= 360) && (pre_yaw >= 350) && (curr_yaw >= 0) && curr_yaw <= 5)
		{
			irc_ang = irc_ang + 360;

		}
		else if ((curr_yaw <= 360) && (curr_yaw >= 350) && (pre_yaw >= 0) && pre_yaw <= 5)
		{
			irc_ang = irc_ang - 360;
		}

		pre_yaw = curr_yaw;
		pcurrent_pos->theta = -(irc_ang + imu_msg_struct.yaw
			- init_imu_yaw_ang)*pi * 1000 / 180 - change_angle;
		odometer(L_l, L_r, wheel_base, &prior_pos, pcurrent_pos);
		//        printf("init_imu_yaw_ang: %f\n",init_imu_yaw_ang);
		printf("current_theta: %f\n", pcurrent_pos->theta);
		//        printf("***********************************************************imu_msg_struct.yaw: %f\n",imu_msg_struct.yaw);
		printf("current x: %f\n", pcurrent_pos->x);
		printf("init x: %f\n", init_x);
		//        printf("***********************************************************current theta: %f\n",pcurrent_pos->theta);


		//        if (curr_msg.bumper_sensor.bumper_sensor1 != 0 ||
		//                curr_msg.bumper_sensor.bumper_sensor2 != 0)
		//        {
		//            stop_cmd(pcurrent_pos, ppre_msg, change_angle, pre_yaw);
		//            pos_ori tem_pos = *pcurrent_pos;
		//            pcurrent_pos->x = cos(change_angle)*tem_pos.x - sin(change_angle)*tem_pos.y;
		//            pcurrent_pos->y = sin(change_angle)*tem_pos.x + cos(change_angle)*tem_pos.y;
		//            pcurrent_pos->theta = tem_pos.theta + change_angle;
		//            return 1;
		//        }

		if (curr_msg.bumper_sensor.right != 0 ||
			curr_msg.bumper_sensor.left != 0)
		{
			stop_cmd(pcurrent_pos, ppre_msg, change_angle, pre_yaw);
			pos_ori tem_pos = *pcurrent_pos;
			pcurrent_pos->x = cos(change_angle)*tem_pos.x - sin(change_angle)*tem_pos.y;
			pcurrent_pos->y = sin(change_angle)*tem_pos.x + cos(change_angle)*tem_pos.y;
			pcurrent_pos->theta = tem_pos.theta + change_angle;
			return 1;


		}

		y = pcurrent_pos->y;
		y_d = slope_line*pcurrent_pos->x + line_b;
		theta = pcurrent_pos->theta;
		cmd.trans_vel = trans_vel_d;
		cmd.ang_vel = motion_controller(y, y_d, theta, theta_d, 0, trans_vel_d, 1);

		set_cmd(xro_cmd_string, cmd.trans_vel, cmd.ang_vel);
		xro_cmd_update = 1;

		memcpy(ppre_msg, &curr_msg, sizeof(curr_msg));
		prior_pos = *pcurrent_pos;

		printf("run times : %d\n", run_times);
		printf("---------------------------------------------------------------\n");
		printf("---------------------------------------------------------------\n");
		usleep(20000);
	}

}

/*************************************************************************/
int_32 CThread_motion::forward_motion(ppos_ori pinit_pos, ppos_ori pcurrent_pos,
	pxrobot_msg ppre_msg, int_32 trans_vel_d, int_32 distance, float cmp_ang)
{

	pos_ori prior_pos;


	int_32 wheel_base = 268;

	xrobot_msg curr_msg;	//解析后，xrobot的信息
	ctrl_cmd cmd;

	float y, y_d;
	float L_l, L_r;
	float change_angle = 0;
	float slope_line, line_b;
	float theta, theta_d;
	float pre_yaw, curr_yaw;

	pos_ori tem_pos = *pinit_pos;
	pinit_pos->x = cos(tem_pos.theta)*tem_pos.x - sin(tem_pos.theta)*tem_pos.y;
	pinit_pos->y = sin(tem_pos.theta)*tem_pos.x + cos(tem_pos.theta)*tem_pos.y;
	pinit_pos->theta = tem_pos.theta - tem_pos.theta;
	change_angle = tem_pos.theta;

	//    pinit_pos->x = cos(des_ang)*tem_pos.x - sin(des_ang)*tem_pos.y;
	//    pinit_pos->y = sin(des_ang)*tem_pos.x + cos(des_ang)*tem_pos.y;
	//    pinit_pos->theta  = pinit_pos->theta - des_ang;
	//    change_angle = des_ang;

	float init_x = pinit_pos->x;

	slope_line = tan(cmp_ang / 1000);


	line_b = pinit_pos->y - slope_line*pinit_pos->x;
	theta_d = cmp_ang;


	prior_pos = *pinit_pos;

	while (1)
	{
		if (x_msg_struct.update == 1)
		{
			memcpy(ppre_msg, px_msg_struct, sizeof(x_msg_struct));
			x_msg_struct.update = 0;
			break;
		}
	}
	printf("---------------------------------------------------------------\n");
	printf("---------------------------------------------------------------\n");


	while (1)
	{
		printf("forward motion\n");
		if (x_msg_struct.update == 1)
		{
			memcpy(&curr_msg, px_msg_struct, sizeof(curr_msg));
			px_msg_struct->update = 0;
			run_times++;
		}
		else
		{
			usleep(5000);
			continue;
		}

		L_l = (curr_msg.left_pos - ppre_msg->left_pos)*0.2167 / 2;
		L_r = (curr_msg.right_pos - ppre_msg->right_pos)*0.2167 / 2;
		curr_yaw = imu_msg_struct.yaw;

		if ((pre_yaw <= 360) && (pre_yaw >= 350) && (curr_yaw >= 0) && curr_yaw <= 5)
		{
			irc_ang = irc_ang + 360;

		}
		else if ((curr_yaw <= 360) && (curr_yaw >= 350) && (pre_yaw >= 0) && pre_yaw <= 5)
		{
			irc_ang = irc_ang - 360;
		}

		pre_yaw = curr_yaw;
		pcurrent_pos->theta = -(irc_ang + imu_msg_struct.yaw
			- init_imu_yaw_ang)*pi * 1000 / 180 - change_angle;
		odometer(L_l, L_r, wheel_base, &prior_pos, pcurrent_pos);
		//        printf("change_angle: %f\n",change_angle);
		//        printf("init_imu_yaw_ang: %f\n",init_imu_yaw_ang);
		//        printf("change_angle: %f\n",change_angle);
		//        printf("imu_msg_struct.yaw: %f\n",imu_msg_struct.yaw);
		//        printf("current x: %f\n",pcurrent_pos->x);
		//        printf("current theta: %f\n",pcurrent_pos->theta);
		printf("***********************************************************imu_msg_struct.yaw: %f\n", imu_msg_struct.yaw);
		//        printf("current x: %f\n",pcurrent_pos->x);
		printf("***********************************************************current theta: %f\n", pcurrent_pos->theta);


		if (curr_msg.bumper_sensor.right != 0 ||
			curr_msg.bumper_sensor.left != 0 || abs(abs(pcurrent_pos->x - init_x) - distance) < 5)
		{
			stop_cmd(pcurrent_pos, ppre_msg, change_angle, pre_yaw);
			pos_ori tem_pos = *pcurrent_pos;
			pcurrent_pos->x = cos(change_angle)*tem_pos.x - sin(change_angle)*tem_pos.y;
			pcurrent_pos->y = sin(change_angle)*tem_pos.x + cos(change_angle)*tem_pos.y;
			pcurrent_pos->theta = tem_pos.theta + change_angle;
			return 1;


		}

		y = pcurrent_pos->y;
		y_d = slope_line*pcurrent_pos->x + line_b;
		theta = pcurrent_pos->theta;

		cmd.trans_vel = trans_vel_d;

		cmd.ang_vel = motion_controller(y, y_d, theta, theta_d, 0, trans_vel_d, 1);

		printf("trans_vel: %d\n", cmd.trans_vel);
		printf("ang_vel: %d\n", cmd.ang_vel);

		set_cmd(xro_cmd_string, cmd.trans_vel, cmd.ang_vel);
		xro_cmd_update = 1;

		memcpy(ppre_msg, &curr_msg, sizeof(curr_msg));
		prior_pos = *pcurrent_pos;

		printf("run times : %d\n", run_times);
		printf("---------------------------------------------------------------\n");
		printf("---------------------------------------------------------------\n");
	}

}
/*******************************************************************/
int_32 CThread_motion::turn_motion(pxrobot_msg ppre_msg, ppos_ori pinit_pos, ppos_ori pcurrent_pos, float des_ang, int_32 span_time)
{
	pos_ori prior_pos = *pinit_pos;

	int_32 wheel_base = 268;
	float L_l, L_r;
	int_32 init_time, curr_time;
	int_32 max_ang_vel = 2 * (des_ang - pinit_pos->theta) * 1000 / span_time;
	float init_ang = pinit_pos->theta;
	float turn_ang = des_ang - pinit_pos->theta;
	int_32 des_ang_vel;
	xrobot_msg  curr_msg;	//解析后，xrobot的信息
	ctrl_cmd cmd;
	float pre_yaw, curr_yaw;


	while (1)
	{
		if (x_msg_struct.update == 1)
		{
			memcpy(ppre_msg, px_msg_struct, sizeof(curr_msg));
			init_time = x_msg_struct.time;
			x_msg_struct.update = 0;
			break;
		}
	}
	//    printf("---------------------------------------------------------------\n");
	//    printf("---------------------------------------------------------------\n");
	pre_yaw = imu_msg_struct.yaw;
	while (1)
	{
		if (x_msg_struct.update == 1)
		{
			memcpy(&curr_msg, px_msg_struct, sizeof(curr_msg));
			px_msg_struct->update = 0;
			run_times++;
		}
		else
			continue;

		L_l = (curr_msg.left_pos - ppre_msg->left_pos)*0.2167 * 2;
		L_r = (curr_msg.right_pos - ppre_msg->right_pos)*0.2167 * 2;

		curr_yaw = imu_msg_struct.yaw;
		if ((pre_yaw <= 360) && (pre_yaw >= 350) && (curr_yaw >= 0) && curr_yaw <= 5)
		{
			irc_ang = irc_ang + 360;

		}
		else if ((curr_yaw <= 360) && (curr_yaw >= 350) && (pre_yaw >= 0) && pre_yaw <= 5)
		{
			irc_ang = irc_ang - 360;
		}
		pre_yaw = curr_yaw;

		pcurrent_pos->theta = -(irc_ang + imu_msg_struct.yaw - init_imu_yaw_ang)*pi*1000 / 180;
		odometer(L_l, L_r, wheel_base, &prior_pos, pcurrent_pos);
		if (abs(des_ang - pcurrent_pos->theta) <= 2 && abs(x_msg_struct.angular_vel) < 10)
		{
			stop_cmd(pcurrent_pos, ppre_msg, 0, pre_yaw);
			return 1;
		}
		cmd.trans_vel = 0;

		curr_time = (curr_msg.time - init_time);
		if ((int_32)curr_time <= (span_time / 2))
		{

			des_ang_vel = (2 * max_ang_vel* curr_time / span_time);
			cmd.ang_vel = (int_32)(des_ang_vel);// +5 * (des_ang_vel*curr_time / 2000 + init_ang - pcurrent_pos->theta));
		}
		else if ((int_32)curr_time < span_time && (int_32)curr_time >(span_time / 2))
		{
			des_ang_vel = (2 * (int_32)(span_time - (int_32)curr_time)*max_ang_vel / span_time);
			cmd.ang_vel = (int_32)(des_ang_vel);// +1 * (init_ang + turn_ang - des_ang_vel*
				//(span_time - curr_time) / 2000 - pcurrent_pos->theta));
		}
		else
		{
			des_ang_vel = 0;
			cmd.ang_vel = 0.5*(des_ang - pcurrent_pos->theta);
		}

		set_cmd(xro_cmd_string, cmd.trans_vel, cmd.ang_vel);
		xro_cmd_update = 1;

		memcpy(ppre_msg, &curr_msg, sizeof(curr_msg));
		prior_pos = *pcurrent_pos;

	}
}

/**********************************************************************************/
int_32 CThread_motion::spin(ppos_ori pinit_pos, ppos_ori pcurrent_pos, int_32 turn_ang)
{
	pos_ori prior_pos = *pinit_pos;

	int_32 wheel_base = 268;
	float L_l, L_r;
	int_32 init_time, curr_time;
	int_32 max_ang_vel = 2 * turn_ang * 1000;
	int_32 init_ang = pinit_pos->theta;
	int_32 des_ang_vel;
	xrobot_msg  curr_msg;	//解析后，xrobot的信息
	ctrl_cmd cmd;
	float pre_yaw, curr_yaw;


	//    while(1)
	//    {
	//        if(x_msg_struct.update == 1)
	//        {
	//            memcpy(ppre_msg, px_msg_struct,  sizeof(curr_msg));
	//            init_time = x_msg_struct.time;
	//            x_msg_struct.update = 0;
	//            break;
	//        }
	//    }
	printf("---------------------------------------------------------------\n");
	printf("---------------------------------------------------------------\n");
	pre_yaw = imu_msg_struct.yaw;
	while (1)
	{
		//        if(x_msg_struct.update == 1)
		//        {
		//            memcpy(&curr_msg, px_msg_struct,  sizeof(curr_msg));
		//            px_msg_struct->update = 0;
		//            run_times++;
		//        }
		//        else
		//            continue;
		//        printf("init_time: %d\n", init_time);
		//        printf("init_ang: %d\n", init_ang);
		//        printf(" x_msg_struct.time: %d\n",  x_msg_struct.time);
		//        printf("Turn motion!\n");
		//        printf("max ang vel: %d\n", max_ang_vel);
		//        printf("init_angle %d\n", init_ang);
		//        printf("init_imu_yaw_ang = %f\n", init_imu_yaw_ang);

		//        L_l = (curr_msg.left_pos - ppre_msg->left_pos)*0.2167;
		//        L_r = (curr_msg.right_pos - ppre_msg->right_pos)*0.2167;
		//        printf("L_l: %f\n",L_l);
		//        printf("L_r: %f\n",L_r);
		curr_yaw = imu_msg_struct.yaw;

		if ((pre_yaw <= 360) && (pre_yaw >= 350) && (curr_yaw >= 0) && curr_yaw <= 5)
		{
			irc_ang = irc_ang + 360;

		}
		else if ((curr_yaw <= 360) && (curr_yaw >= 350) && (pre_yaw >= 0) && pre_yaw <= 5)
		{
			irc_ang = irc_ang - 360;
		}

		pre_yaw = curr_yaw;
		pcurrent_pos->theta = -(irc_ang + imu_msg_struct.yaw
			- init_imu_yaw_ang)*pi * 1000 / 180;

		//        odometer(L_l, L_r, wheel_base, &prior_pos, pcurrent_pos);
		//        printf("irc_ang = %f\n", irc_ang);
		//        printf("current x: %f\n",pcurrent_pos->x);
		//        printf("current theta: %f\n",pcurrent_pos->theta);
		//        curr_time = (curr_msg.time - init_time);
		//        printf("current time: %d\n",curr_time);
		//        printf("span_time: %d\n",span_time);

		//        if (abs(pcurrent_pos->theta - init_ang - turn_ang) <= 5 )
		//        {

		//            stop_cmd(pcurrent_pos,  ppre_msg, 0, pre_yaw);
		//            return 1;

		//        }
		cmd.trans_vel = 0;

		cmd.ang_vel = 2 * (0 - pcurrent_pos->theta);


		printf("*****************imu_msg_struct.yaw: %f************************\n", imu_msg_struct.yaw);
		//        printf("cmd.trans_vel: %d\n",cmd.trans_vel);
		//        printf("cmd.ang_vel: %d\n",cmd.ang_vel);
		//        printf("cmd.trans_vel: %2X\n", cmd.trans_vel);
		//        printf("cmd.ang_vel: %2X\n", cmd.ang_vel);
		set_cmd(xro_cmd_string, cmd.trans_vel, cmd.ang_vel);
		xro_cmd_update = 1;
		//printf("here002\n");
		//set_cmd(send_cmd, cmd.trans_vel, 100);
		//                int ret_val = send_data(fid, send_cmd, 34);

		//                printf("\nhere001 send cmd ret value: %d  ***************\n", ret_val);
		//        memcpy(ppre_msg, &curr_msg,  sizeof(curr_msg));
		prior_pos = *pcurrent_pos;


		printf("run times : %d\n", run_times);
		printf("---------------------------------------------------------------\n");
		printf("---------------------------------------------------------------\n");
		usleep(20000);
	}
}
/**********************************************************************************/
int_32 CThread_motion::motion()
{
	pos_ori init_pos;
	pos_ori curr_pos;
	init_pos.x = 0;
	init_pos.y = 0;
	init_pos.theta = 0;
	float des_ang = 0;
	int_32 cmp_ang = 0;
	int_32 motion_times = 0;
	float gain1 = 1;
	float gain2 = 1;
	float init_ang = 0;



	xrobot_msg pre_msg;
	while (1)
	{
		if (x_msg_struct.update == 1)
		{
			memcpy(&pre_msg, px_msg_struct, sizeof(pre_msg));
			x_msg_struct.update = 0;
			break;
		}
	}


	while (1)
	{
		run_times++;
		init_imu_yaw_ang = imu_msg_struct.yaw;


		if (motion_times != 0)
		{
			gain1 = 1;
			gain2 = 1;
		}


		usleep(10000);
		line_motion(&init_pos, &curr_pos, &pre_msg, 200, init_ang, cmp_ang);
		init_pos = curr_pos;
		update_msg(&pre_msg, &init_pos, &curr_pos);

		usleep(100000);
		forward_motion(&init_pos, &curr_pos, &pre_msg, 100, -100, cmp_ang);
		init_pos = curr_pos;
		update_msg(&pre_msg, &init_pos, &curr_pos);


		usleep(10000);
		turn_motion(&pre_msg, &init_pos, &curr_pos, init_ang + 1570 * gain1, 8000);
		init_pos = curr_pos;
		update_msg(&pre_msg, &init_pos, &curr_pos);
		cmp_ang = cmp_ang + (1570 - 1570 * gain1);
		
		usleep(100000);
		forward_motion(&init_pos, &curr_pos, &pre_msg, 100, 300, cmp_ang);
		init_pos = curr_pos;
		update_msg(&pre_msg, &init_pos, &curr_pos);

		usleep(10000);
		turn_motion(&pre_msg, &init_pos, &curr_pos, init_ang + 2 * 1570 * gain1, 8000);
		init_pos = curr_pos;
		update_msg(&pre_msg, &init_pos, &curr_pos);
		cmp_ang = cmp_ang + 2 * (1570 - 1570 * gain1);
		
		usleep(100000);
		line_motion(&init_pos, &curr_pos, &pre_msg, 200, init_ang + 2 * 1570 * gain1, cmp_ang);
		init_pos = curr_pos;
		update_msg(&pre_msg, &init_pos, &curr_pos);
		
		usleep(100000);
		forward_motion(&init_pos, &curr_pos, &pre_msg, 100, -100, cmp_ang);
		init_pos = curr_pos;
		update_msg(&pre_msg, &init_pos, &curr_pos);
	
		usleep(100000);
		turn_motion(&pre_msg, &init_pos, &curr_pos, init_ang + 2 * 1570 * gain1 - 1570 / gain2, 8000);
		init_pos = curr_pos;
		update_msg(&pre_msg, &init_pos, &curr_pos);
		cmp_ang = cmp_ang + (1570 - 1570 / gain2);

		usleep(100000);
		forward_motion(&init_pos, &curr_pos, &pre_msg, 100, 300, cmp_ang);
		init_pos = curr_pos;
		update_msg(&pre_msg, &init_pos, &curr_pos);
	
		turn_motion(&pre_msg, &init_pos, &curr_pos, init_ang + 2 * 1570 * gain1 - 2 * 1570 / gain2, 8000);
		init_pos = curr_pos;
		update_msg(&pre_msg, &init_pos, &curr_pos);
		cmp_ang = cmp_ang + 2 * (1570 - 1570 / gain2);

		init_ang = 2 * 1570 * gain1 - 2 * 1570 / gain2 + init_ang;
		cmp_ang = 0;
		motion_times++;




	}

	return 0;

}

/***********************************************************************/
void CThread_motion::stop_cmd(ppos_ori pcurrent_pos, pxrobot_msg ppre_msg, float change_angle, float pre_yaw)
{
	uint_8 send_cmd[64];
	int stop_count = 0;
	int_32 wheel_base = 268;
	float curr_yaw;

	set_cmd(send_cmd, 0, 0);
	//TODO cmd update
		xro_cmd_update = 1;
	//send_data(fid, send_cmd, 34);

	float  L_l, L_r;

	pos_ori prior_pos = *pcurrent_pos;

	memcpy(ppre_msg, px_msg_struct, sizeof(xrobot_msg));

	while (1)
	{
		stop_count++;
		while (1)
		{
			if (x_msg_struct.update == 1)
			{
				x_msg_struct.update = 0;
				break;
			}
		}

		L_l = (x_msg_struct.left_pos - ppre_msg->left_pos)*0.2167;
		L_r = (x_msg_struct.right_pos - ppre_msg->right_pos)*0.2167;
		printf("stop_cmd-- L_l: %f\n", L_l);
		printf("stop_cmd-- L_r: %f\n", L_r);

		curr_yaw = imu_msg_struct.yaw;

		if ((pre_yaw <= 360) && (pre_yaw >= 350) && (curr_yaw >= 0) && curr_yaw <= 5)
		{
			irc_ang = irc_ang + 360;
		}
		else if ((curr_yaw <= 360) && (curr_yaw >= 350) && (pre_yaw >= 0) && pre_yaw <= 5)
		{
			irc_ang = irc_ang - 360;
		}

		pre_yaw = curr_yaw;
		pcurrent_pos->theta = -(irc_ang + imu_msg_struct.yaw
			- init_imu_yaw_ang)*pi * 1000 / 180 - change_angle;

		odometer(L_l, L_r, wheel_base, &prior_pos, pcurrent_pos);
		printf("stop_cmd-- current_pos.x: %f\n", pcurrent_pos->x);
		printf("stop_cmd-- current_pos.theta: %f\n", pcurrent_pos->theta);
		memcpy(ppre_msg, px_msg_struct, sizeof(x_msg_struct));
		prior_pos = *pcurrent_pos;
		set_cmd(xro_cmd_string, 0, 0);
		xro_cmd_update = 1;
		printf("---------------------------------------------------------------\n");
		printf("---------------------------------------------------------------\n");

		if (abs(L_l) < 0.01 && abs(L_r) < 0.01)
			return;
	}
}

/*************************************************************************/

void CThread_motion::update_msg(pxrobot_msg ppre_msg, ppos_ori pinit_pos, ppos_ori pcurrent_pos)
{
	int_32 wheel_base = 268;
	float L_l, L_r;

	printf("Update msg.\n");

	while (1)
	{
		if (x_msg_struct.update == 1)
		{
			L_l = (x_msg_struct.left_pos - ppre_msg->left_pos)*0.2167;
			L_r = (x_msg_struct.right_pos - ppre_msg->right_pos)*0.2167;
			x_msg_struct.update = 0;
			break;
		}
	}

	L_l = (x_msg_struct.left_pos - ppre_msg->left_pos)*0.2167;
	L_r = (x_msg_struct.right_pos - ppre_msg->right_pos)*0.2167;
	odometer(L_l, L_r, wheel_base, pinit_pos, pcurrent_pos);
	memcpy(pinit_pos, pcurrent_pos, sizeof(*pcurrent_pos));
	memcpy(ppre_msg, px_msg_struct, sizeof(x_msg_struct));

	printf("current x: %f\n", pcurrent_pos->x);
	printf("current theta: %f\n", pcurrent_pos->theta);

	return;
}
/*************************************************************************/
int_32 CThread_motion::odometer(float L_l, float L_r, int_32 wheel_base, ppos_ori pprior_pos, ppos_ori current_pos)
{

	float sum_dis = L_l + L_r;
	float differ_dis = L_r - L_l;
	float deta_theta;

	printf("Debug sum_dis = %f\n", sum_dis);
	printf("Debug differ_dis = %f\n", differ_dis);

	current_pos->x = pprior_pos->x + sum_dis*(cos(current_pos->theta / 1000) + cos(pprior_pos->theta / 1000)) / 4;
	current_pos->y = pprior_pos->y + sum_dis*(sin(current_pos->theta / 1000) + sin(pprior_pos->theta / 1000)) / 4;

	return 1;
}

int_32 CThread_motion::motion_controller(float y, float y_d, float theta, float theta_d,
	int_32 angluar_vel_d, int_32 trans_vel_d, int_32 cir_sign)
{
	int_32 k1 = 8;
	int_32 k2 = 4;
	float x1 = y_d / 1000 - y / 1000;
	float x2 = (tan(theta_d / 1000) - tan(theta / 1000));
	printf("x1 = %f\n", x1);
	printf("x2 = %f\n", x2);
	printf("cir_sign = %d\n", cir_sign);
	printf("angluar_vel_d = %d\n", angluar_vel_d);
	float a_vel = (pow(cos(theta / 1000), 3)*trans_vel_d*(k1*x1 + k2*x2)
		+ angluar_vel_d);
	printf("a_ve = %f\n", a_vel);
	int_32 angluar_vel = a_vel;
	printf("angluar_vel = %d\n", angluar_vel);
	return angluar_vel;
}

